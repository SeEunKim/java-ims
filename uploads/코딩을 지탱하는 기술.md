# 코딩을 지탱하는 기술

### 시작하며

---

학습에는 3가지 중요한 포인트가 있다.

1. 비교를 통한 학습

   - 다수의 언어를 비교하는 것
   - 무엇이 그 언어만이 가진 특유의 개념이고, 무엇이 언어 간에 공통으로 사용되는 개념인지를 배울 수 있음

2. 역사를 통한 학습

   * 언어의 발달 과정을 따라가는 것
   * 어떻게 탄생했고, 어떤 식으로 변화해 왔는지를 배움으로 '왜 이런 식으로 동작하고 있는지'에 대한 의문을 풀 수 있음

3. 만드는 것을 통한 학습

   * 직접 언어를 만드는 것

   * '나라면 어떻게 만들까?'를 생각함으로, 언어 설계자의 의도를 쉽게 이해할 수 있게 된다. 또한 실제로 만들어 봄으로써 자신이 잘 이해하지 못한 것을 알 수 있게 된다.

---

### 이 책의 구성

---

1. 언어를 효율적으로 학습하기 위한 '비교를 통한 학습'과 '역사를 통한 학습'에 관해 구체적인 예를 들어 설명한다.

2. 프로그래밍 언어 자체가 왜 탄생했는지 역사를 따라가며 배워 나간다.

   * 3장 이후로는 프로그래밍 언어에 관한 여러 가지 개념에 대해 설명한다. 특정 언어에 관한 지식을 전제로 하고 있진 않지만, 여러분들의 경험과 연관되지 않을 경우 이해하기 어려울 수도 있다. 예를 들어 C 언어만 경험했다면 6장의 '에러 처리'를 이해하기 어려울 것이다. 또한 스레드를 사용한 적이 없다면 10장의 '병행처리'를 이해하기 어려울 것이다. 그런 경우에는다른 장을 먼저 읽어도 상관없다. 

3. 프로그래밍 언어에 왜 수많은 문법(규칙)이 존재하는지 설명한다. 특히 연산자의 우선순위를 중심으로, 규칙이 적은 언어인 FORTH나 LISP를 비교하며 배운다.

4. If문, while문, for문 등 '제어 구문'이 왜 탄생했는지, 제어 구문이 없는 어셈블리 언어와 제어 구문이 있는 C 언어를 비교해서 학습한다.

5. '함수'가 왜 탄생했는지를 배운다. 또한 '재귀 호출'이 어떤 경우에 필요한지 학습한다.

6. 현재 많은 언어에서 '예외'라고 부르고 있는 '에러 처리' 구조가 왜 필요했는지, 어떻게 탄생하게 됐는지에 대해 학습한다.

7. 변수나 함수의 '이름'이 왜 탄생했는지, 그리고 '스코프(scooe)'가 왜 필요했으며 어떻게 진화해 왔는지를 학습한다. 

8. '형'에 대해 학습한다. 형이 왜 필요하게 됐는지 구체적으로 학습하기 위해 우선 '숫자를 어떻게 표현하는지'를 배우고, 형과 그 응용 방법에 대해 학습한다.

9. '객체를 저장할 수 있는 공간('컨테이너, container)에 대해 학습한다. 컨테이너에는 다양한 종류가 있지만 왜 그렇게 종류가 다양한지, 차이를 비교해 각각의 장단점을 파악한다.

   후반부에는 '문자열'에 대해 배운다. 문자 인코딩(encodind)의 변천사를 확인하며, 언어에 따라 문자열이 어떻게 다른지 비교를 통해 학습한다. 

10. 복수의 처리를 통시에 실행하는 '병행 처리'의 문제점과 대안책에 대해 각종 언어를 비교하며 학습한다. 

11. '객체 지향'에 대해 학습한다. 객체 지향이 의미하는 바가 언어에 따라 다른 것을 Smalltalk와 c++을 비교하며 배운다. 다음으로, 왜 객체 지향이 발명됐는지 역사를 통해 확인한다. 또한 '클래스'와 '객체를 만드는 다양한 방법'에 대해 학습한다.

12. '상속'에 대해 학습한다. 여러 언어에서 사용되고 있는 상속 구조를 비교하여 각각의 장단점을 배운다. 



---

### 1장 효율적으로 언어 배우기

---

1. 비교를 통한 배움

   * 많은 언어에서 공통적으로 사용되는 개념이야말로 중요한 지식.

   1. 규칙은 언어마다 다르다.
   2. C언어와 Ruby의 참거짓 값
      * C언어 : 0이 거짓, 그 이외의 값은 참이다.
      * Ruby : 0이 참이다.
   3. Java의 참거짓 값
      * 참 거짓값을 위한 형을 가지고 있음
      * 0은 단순히 정수형을 의미
      * 조건식에 0을 사용하면 컴파일 에러가 발생

2. 역사를 통한 배움

   1. 언어 설계자의 의도를 이해하자.
      * 언어 설계자는 어떤 문제를 해결하기 위해 그 언어를 만든 것일까? 
      * 그 언어가 어떤 흐름을 따라 만들어졌는지 알게 되면 그 기능이 왜 필요한지 납득할 수 있게 된다.
   2. 어떤 언어를 배워야 하는지는 아무도 모른다.
   3. 언어에 의존하지 않는 보편적인 지식의 습득

3. 정리

   * 특정 언어에 국한된 지식이 아니라, 보다 보편적인 지식을 습득할 수 있도록 하고 있음. 이를 위해 '비교를 통한 배움'과 '역사를 통한 배움'이라는 2가지 방법을 사용한다.
   * '비교를 통한 배움'이란 특정 언어로 프로그래밍을 배우는 것이 아니라, 다수의 언어를 비교해 가면서 학습하는 것을 의미한다. 이를 통해, 무엇이 언어에 따라 다르고 무엇이 공통적인지 배울 수 있다. 
   * '역사를 통한 배움'이란 언어가 어떻게 바뀌었고 바뀌기 전에는 어떤 의문점이 존재했는지 학습하는 것을 의미한다. 이를 통해, 언어가 가지고 있는 다양한 기능이 '왜' 탄생했는지 배울 수 있다.

---

### 2장 프로그래밍 언어를 조감하다.

---

1. 프로그래밍 언어 탄생의 역사

   * 프로그래밍 언어를 만든 목적은 무엇일까? 
   * 인간을 편하게 하기위해 만들어졌다.

   1. 케이블을 연결하다
      * 1946년 ENIAC 발명
      * 이 컴퓨터는 목적에 따라 프로그램을 변경할 수 있음
      * 프로그램을 변경할 때마다 케이블의 연결을 바꾸는 것은 매우 힘든 일
   2. 프로그램 내장 방식으로
      * 1949년 EDSAC 개발
      * 물리적 케이블을 교환하는 대신, 종이 테이프의 데이터를 읽어 들여서 프로그램을 변경할 수 있음.
      * 사람이 프로그램을 읽거나 쓰는 것은 어려움, 기계가 읽기 위한 기계어였기 때문.
   3. FORTRAN의 등장
      * 1954년 FORTRAN 등장
      * Formula Translating System(수식 변환 시스템) - 수식을 기계어로 변환하는 것

2. 프로그래밍 언어 탄생의 목적

   * 프로그램은 어떤 것을 편하게 하기 위해 고안된 것

   1. 나태 - 프로그래머의 삼대 미덕

      * 프로그래밍 언어 Perl의 설계자인 Larry Wall은 저서 "Programming Perl"에서 프로그래머가 가져야 할 3가지 자질로서 '나태, 조바심, 자만심'을 제안

        > 나태(Laziness)
        >
        > 전체 에너지 소비를 줄이기 위해 대부분의 능력을 집중하는 기질, 이렇게 노동력을 줄이기 위해 만든 프로그램은 다른 사람들도 사용하게 되며, 그 프로그래머에 관한 질문에 일일이 답하는 수고를 덜기 위해 문서를 만들게 된다. 이는 프로그래머에게 있어 가장 중요한 자질이기도 하며, 이 책이 존재하는 이유이기도 하다. 조바심과 자만심에 관해서도 참조할 것.

      * 같은 성과를 달성하는 다수의 방법 중 가장 생산성이 높은 것을 선택함

   2. 언어에 따라 다른 '편리함'의 의미

      1. 무엇을 편하게 하고 싶은 것인가?
         * c++ : 빠른 실행 속도를 중시하고 있는 언어, 
         * Scheme : 언어 사양을 쉽게 파악할 수 있는데 중점을 두고 있는 언어.
      2. 어떤 프로그램을 편하게 만들고 싶은가?
         * Python은 다른 사람이 쓴 코드를 쉽게 해석할 수 있는데 중점, 속도가 느리며, 사양도 단순하지 않다.
         * PHP는 웹 서비스를 쉽게 만들 수 있도록 해줌, 문장 처리를 편하게 하지는 못한다. 

3. 정리

   * 언어는 도구다.
   * 어떤 언어가 자신의 목적에 적합한지는 그 언어를 사용할 때 자신이 어느 정도 생산성을 발휘할 수 있는지로 판단할 수 있음.

---

### 3장 문법의 탄생

---

1. 문법이란?

   * 프로그래밍 언어 설계자가 만든 '이렇게 쓰면 이런 의미로 해석된다'라고 정한 규칙

   1. 연산자 우선순위
      * 1 + 2 * 3 ? (1 + 2) * 3 or 1 + (2 * 3)
      * 프로그래밍 설계자가 '+'보다 '*'가 우선순위가 높기 때문에 먼저 계산한다는 규칙을 정했기 때문에 7이나옴.
      * 9 / 3 / 3 ? (9 / 3) / 3 or 9 / (3 / 3)
      * 프로그래밍 설계자가 '/'은 좌결헙사어 연산자이기 때문에 나열되어있는 순서대로 먼저 계산한다 는 규칙을 정함. 
   2. 문법은 언어 설계자가 정한 규칙

2. 스택 머신과 FORTH

   * FORTH는 1958년 경에 개발되어 문법이 거의 존재하지 않는 언어

   1. 계산 순서 
      * 스택을 이용하여 계산
   2. 연산 순서를 어떻게 표현할까?
      * 1 더하기 2 : 1 2 + 
      * 1에 2를 더하고 그 결과에 3을 곱하는 것 : 1 2 + 3 *
   3. 현재도 살아있는 스택 머신

3. 구문 트리와 LIST

   * LISP는 1958년에 개발, 하나의 구역을 표현하기 위해 항상 괄호를 사용한다.

   1. 계산의 흐름
   2. 계산순서를 어떻게 표현할까?
      - 1 더하기 2 : (+ 1 2)
      - 1과 2를 더한 후 3을 곱한다 : (* (+ 1 2 ) 3)
   3. 현재도 살아있는 구문 트리

4. 중위 표기법

   * 1 2 + (후위 표기법, 연산자를 연산 대상 뒤에 두는 것)
   * '+' 1 2 (전위 표기법, 연산자를 연산 대상 앞에 두는 것)
   * 1 + 2 (중위 표기법, 연산자를 연산 대상 사이에 두는 것)

   1. 구문 해석기 
      - 구문해석기(파서, Parser)는 소스 코드를 문자열로 읽어 들어 해석하고, 그것을 구문 트리로 만드는 프로그램이다. 

   1. 규칙간 마찰
      - C++ 템플릿 기능 추가할 때 vertor<int> 와 같이 '부등호로 감싸는 표기'를 도입했다. 
      - 그러나 이 부등식 괄호를 이중으로 하면 괄호를 닫는 >> 가 기존의 '쉬프트(shift) 연산자''로 해석되어 버린다. 
      - 이 문제를 구문 분석기에서 해결하는 것이 쉽지 않아서 프로그래머가 공백 문자를 사이에 입력해서 >>가 되지 않도록 하는, 운영 측면에서 문제를 해결
      - vector<vector<int> > x; // ok
      - vector<vector<int>> y; // ng 

5. 정리

   * '1 더하기 2에 3을 곱한다'는 똑같은 처리도 언어에 따라 표현 방법이 틀리다.
   * 그러나 구문 트리로 표현하면 거의 동일하다. 
   * 이들 언어에 차이가 생긴 것은'어떤 문자열을 쓰면 어떤 구문 트리가 생기는가'라는 규칙이다. 
   * 이것이 문법이다.

> 무엇을 배우면 좋을지 모르는 이유
>
> > '무엇을 만들고 싶은가?' 목적을 명확히 하는 것이다. 그리고 목적을 달성하기 위해 필요한 것부터 배우면 된다.

> 이해력을 확인하기 위해서는 결과물(Output)을 확인한다.

---

### 4장 처리 흐름 제어

---

1. 구조화 프로그래밍의 탄생

2. if가 탄생하기 전

   1. if는 왜 있는 걸까?
   2. If-else는 왜 있는 걸까?
      1. 어셈블리어의 표현 방법
      2. C언어의 표현 방법
      3. If-else 사용의 장점
         * '조건이 참인 경우와 거짓인 경우의 처리 흐름을 분배한다.'

3. while, 반복되는 if를 읽기 쉽게 표현

   * while : 조건을 만족하고 있는 동안 블록 안의 내용을 반복하여 실행

   1. while 문을 사용하는 방법
   2. while 문을 사용하지 않는 방법
      * goto는 강력하고 이해하기 쉬운 개념, 너무 원시적, 남용금지!

4. for, 수치를 증가시키는 while을 읽기 쉽게 표현

   1. for를 사용하는 방법
   2. for를 사용하지 않는 방법
   3. foreach, 처리 대상으로 반복 제어
      * while : 조건식으로 반복을 제어
      * for : 횟수로 반복을 제어
      * foreach : 처리 대상을 반복 제어 

5. 정리

---

### 5장 함수

---

1. 함수의 역할
   1. 이해(조직을 예로)

      * 큰 조직이 부서로 나눠져 있는 것과 닮았다.
      * 사람수가 늘었을 경우, 모든 것을 파악하는 것이 어려워 진다. 그래서 몇 명을 하나의 그룹으로 묶어서 이름을 붙이게 된다. 예)경리과, 개발팀

      * 소스 코드의 행수가 많아지면 전체를 파악하기 어렵게 된다. 그래서 몇 개의 행을 하나의 그룹으로 묶어서 거기에 이름을 붙이는 것이다. 

      * 이것이 함수다!

   2. 재사용(부품을 예로)

      * 작은 부품을 조립해서 큰 부품을 만드는 것과 비슷하다. 
      * 무선 조정 자동차에는 알칼리 전지나 모터가 들어있다. 알칼리 전지나 모터를 특정 위치에 설치해야 무선 조정 자동차가 완성된다.
      * 알칼리 전지(만드는 법 복잡함..)를 직접 만들지 않아도 알칼리 전지를 구할 수 있다. 
      * 수십 행, 수백 행의 코드가 함수로 정리되고 제공되고 있어서 쉽게 그 함수를 호출해서 사용할 수 있다. 

   3. 프로그램 재사용의 특징

      * 프로그램을 만드는 것과 물리적인 것을 만드는 것에는 크게 다른 점이 하나 있다. 그것은 부품을 재사용하고 싶을 때 드는 비용이다.
      * 함수는 200회 호출 한다고 해서 200개를 만들 필요가 없다.
      * 같은 처리를 한 군데에 정리하여 생기는 이점은 단순히 프로그램이 짧아지는 데에만 있지 않다. 소스 코드를 읽는 사람이 몇 번이고 같은 내용의 소스코드를 읽을 필요도 없어진다. 
      * 길게 늘려있는 명령들을 자주 사용되는 단위로 잘라내어 정리함으로써 프로그램을 보다 쉽게 이해할 수 있게 된다. 

2. 돌아가는 명령

   * goto 문으로 못하는 것. 그것은 바로 '원래 위치로 돌아가'는 것이다. 
   * 점프할 때 '어디에서 점프해 왔는지'를 기억해두고, 나중에 '돌아가'는 명령을 만나면 점프 명령 직후로 점프하게 하고 싶은 것이다. 
   * '원래 위치로 돌아가'는 명령이 가능하면 코드를 재사용할 수 있게 된다. 하나의 프로그램 안에서 동일한 처리가 여러번 이뤄지면 그것을 한곳에 모아두는 것이 가능하다.

   1. 함수의 탄생
      * '몇 번이고 반복해서 사용하는 명령을 한 곳에 모아두어 재사용하고 싶다.'는 필요성은 꽤 오래 전부터 있었다.
   2. 돌아갈 목적지를 기록하기 위한 전용 메모리
      * 함수 호출 전으로 돌아가도록 하는 명령의 점프 목적지를 변경하기 위해, 함수를 호출하는 사람이 '점프 목적지가 어딘지', '돌아가는 명령이 있는 곳은 어디인지'를 상호간에 파악해둬야만 했다. 
      * 예를 들어, 함수 내용을 조금 바꿔서 돌아가는 명령의 위치가 뒤로 옮겨졌다고 치자, 그러면 그 함수를 호출하고 있는 코드를 전부 수정해야만 한다. 
      * 이후, 돌아갈 목적지를 기록해두는 전용 메모리를 만들어 '돌아갈 목적지 메모리에 적어둔 번지로 점프하는 명령'을 준비해두는 방법.
      * 이것으로 호출처가 '돌아가는 명령의 위치'를 파악해둘 필요가 없어졌다.
      * 이 방법의 문제점 -> 함수 X를 호출하고 있는 중에 다른 함수 Y를 호출하면, 돌아갈 목적지 메모리에 덮어 씌워져서 함수 x가 돌아갈 목적지를 잊어버리게 된다.
   3. 스택
      * 스택은 복수의 값을 저장해 두는 데이터 구조로, 마지막에 넣은 것을 가장 먼저 꺼내는 경우에 적합하다. 

3. 재귀 호출

   * 재귀 호출이란 함수 X 안에서 함수 X 자신을 호출하는 것

   1. 내포 구조 데이터의 효율적 처리
      * '어떤 처리를 하고 있는 도중에 동일한 처리를 다른 대상(인수)에 대해 실행한다.'는 내포(nesting) 형태의 처리
   2. 내포 구조를 다루는 방법
      1. for로 구현할 수 없다.
      2. 재귀 호출을 사용
      3. 재귀 호출의 처리 흐름

4. 정리

   * 프로그램의 규모가 커지면 전체적인 구조를 파악하기 어려워진다. 또한 비슷한 처리를 몇 번이고 반복해서 쓰고 싶어지는 경우도 생긴다.
   * 함수는 이 문제를 해결하기 위해 탄생했다.
   * 한 그룹인 코드를 빼내어 의미 있는 이름을 붙여서, 그 코드가 무엇을 하고 있는지 파악하기 쉬워진다. 
   * 그리고 그 함수를 다른 장소에서 호출하여 사용함으로 재사용도 가능해진다.
   * 또한 함수를 사용함으로 '재귀 호출'이라는 코딩 기술이 탄생했다. 이것은 내푸 구조로 된 데이터를 다루기에 적합한 기법이다.  

> 이름
>
> >함수를 사용한 처리에 이름을 붙이는 행위는 '처리가 시작되는 메모리상의 위치'를 수치로 표현하는 대신, 알기 쉬운 문자열로 표현하는 행위다. 이것은 변수도 마찬가지다. 변수도 '값이 기록된 메모리 위치'를 수치가 아닌 문자열로 표현하기 위해 만들어졌다.

---

### 6장 에러처리

---

1. 프로그램도 실패를 한다.

   * 프로그램도 실패를한다. 
   * 예를 들어, 파일에 무엇을 기록하려고 할 때 하드 디스크가 이미 꽉 차 있는 경우 기록에 실패한다.
   * 파일에 기록하려고 했는데 실패한 경우에 어떤 경고도 없다면 사용자는 실패를 알아차리기 힘들다. 
   * '실패를 알리는 구조'가 필요하다.

2. 실패를 어떻게 전달할까?

   * 에러 처리를 구현하는 방법에는 2가지가 있다.
     * 함수가 반환값으로 실패를 전달하면 호출처가 반환값을 체크해서 에러 처리를 하는 방법
     * 함수를 호출하기 전에 에러 처리 코드를 등록해두고, 실패 시 에러 처리 코드로 점프하는 방법

   1. 반환값으로 실패를 전달한다. 
      1. 실패를 놓친다.
         * 프로그래머가 함수를 사용한 후 반환값을 체크 하지 않고 '처리는 성공했다.'고 생각해버리는 코드를 쓰게 된다.
      2. 에러 처리 때문에 코드를 해석하기 어렵다.
      3. 점프로 에러 처리를 정리한다.
   2. 실패하면 점프한다.
      1. UNIVAC 1의 경우
         * '에러가 발생했을 때 점프한다.'는 발상은 프로그래밍 언어보다 먼저 존재했다.
         * '계산 시 오버플로우(overflow)가 발생하면 ** 번지에 있는 명령을 실행한다.'는 기능 -> 인터럽트(interrupt)
      2. COBOL의 경우
         * 파일 읽을 때 데이터가 없는 경우
         * 오버 플로우가 발생한 경우 
         * 에러는 2가지밖에 없었음
      3. PL/I의 경우
         * 실패 종류를 추가할 수 있는 기능
         * 실패를 발생시킬 수 있는 기능

3. 실패할 것 같은 처리를 묶는 구문

   * PL/I는 미리 실패했을 때 처리를 등록해둔 후 실패할 것 같은 코드를 쓰는 형식
   * 현재는 실패할 것 같은 코드를 미리 try{}로 묶어둔 후 실패했을 때 처리를 쓰는 형식

   1. John Good enough의 주장
   2. CLU에 도입
   3. C++에 도입
   4. Windows NT3.1에 도입

4. 출구는 하나다

   1. 왜 finally를 도입한 것일까?

      * Microsoft 사의 finally도입에 대한 대답
      * 구조화 예외 처리를 채용함으로 코드의 신뢰성을 높일 수 있었다. 예를 들어, 프로그래머가 예측하지 못한 종료가 발생했을 시 메모리 블록이나 파일 등의 리소스를 잘 닫을 수 있게 된다. 또한 메모리 부족 등의 특정 문제에 대해서도 goto 구문이나 반환값 개념을 사용하지 않고 간단한 구조화 코드로 대응할 수 있다.  

   2. 짝이 되는 처리를 반드시 실행한다.

      * 메모리 확보후 해제
      * 파일을 열었다 닫는 처리 등 

      1. finally를 사용해서 해결
         * finally 블록은 처리가 try 블록에서 벗어날 때 반드시 실행된다.
      2. Finally가 없는 C++에서의 해결
         * RAII(Resource Acquisition Is Initialization :  리소스 확보는 초기화 시에)
      3. D언어의 scope(exit)를 사용한 해결

5. 어떤 경우에 예외를 던질까?

   1. 함수 호출 시 인수가 부족한 경우
      * Python, Ruby : 함수 호출 시점에서 예외 던짐
      * JavaScript는 인수에 '미정의를 의미하는 특수한 값'을 사용해서 처리 계속 진행
   2. 배열 범위 밖에 있는 것을 취득하려고 했을 때
      * Python : 예외 던짐
      * Ruby : 없는 것을 의미하는 특수한 값(nil) 반환
      * JavaScript : undefined 반환
   3. 틀리면 바로 예외를 던진다.

6. 예외의 전파

   1. 예외 전파의 문제점
      * 함수가 호출하는 모든 함수의 소스코드를 보지 않으면 함수가 어떤 예외를 던질 가능성이 있는지 알 수 없다. 깜빡하고 예외가 던져질 가능성을 놓치고 있다면 프로그램이 비정상종료되어 버릴 수 있다는 것
   2. Java의 검사 예외
      * '예외'라고 부르는 것을 세분화
      * '예외 처리를 하지 않아도 되는 중요한 문제'
      * '예외 처리를 해도 좋은 기타 예외' 등등
   3. 검사 예외가 잘 사용되지 않은 이유
      * 귀찮기 때문
      * 예외의 갯수가 너무 방대해짐
      * 어떤 메소드에서 던질 예욀르 하나 추가하면 그 메소드를 호출하고 있는 모든 메소드를 수정해야만 한다. 

7. 정리

   * 실패를 전달하는 방법은 2가지, 반환값을 알린다. 실패하면 점프한다.
   * 반환값으로 알린다 : 반환값을 확인하는 것을 잊어버려서 실패를놓칠 수 있다는 문제가 있음
   * 실패하면 점프한다. : 예외처리
   * 예외 처리의 문제점 : '짝을 이루는 처리'가 어렵다, 함수가 어떤 예외를 던질지 그 함수의 코드를 확인해도 알 수 없다는 문제
   * 실패를 전달하는 방법 2가지에는 어느 쪽에도 장단점이 있어서 각각의 장단점을 잘 파악한 후 적재적소에 사용하는 것이 중요.

> 구체적인 지식과 추상적인 지식

> 이빨로 씹다

> 필요한 부분부터 흡수한다.

---

### 7장 이름과 스코프

---

1. 이름이 왜 필요할까?
   1. 어떻게 이름을 붙일까?
   2. 이름 충돌
   3. 충돌 피하기
      1. 긴 변수명을 사용한다.
      2. 스코프를 이용한다
2. 스코프의 진화
   1. 동적 스코프
      1. 어떤 방식으로 동작하는가
      2. 문제점
   2. 정적 스코프
      1. 동적 스코프는 대응표를 코드 전체에서 읽을 수 있다.
      2. 정적 스코프는 함수별로 대응표를 나눈다.
3. 정적 스코프는 완성체인가?
   1. 내포함수의 문제점
   2. 외부 스코프에 재귀속되는 문제
      1. Python에서의 해결 방법
      2. Ruby에서의 해결 방법
4. 정리